
// Generated by Cadence Genus(TM) Synthesis Solution GENUS15.20 - 15.20-p004_1
// Generated on: May 23 2025 23:34:20

// Verification Directory fv/synth_wrapper 

module DFF(in, clk, rst_n, out);
  input [3:0] in;
  input clk, rst_n;
  output [3:0] out;
  wire [3:0] in;
  wire clk, rst_n;
  wire [3:0] out;
  wire n_5;
  not g1 (n_5, rst_n);
  CDN_flop \out_reg[0] (.clk (clk), .d (in[0]), .sena (1'b1), .aclr
       (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (out[0]));
  CDN_flop \out_reg[1] (.clk (clk), .d (in[1]), .sena (1'b1), .aclr
       (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (out[1]));
  CDN_flop \out_reg[2] (.clk (clk), .d (in[2]), .sena (1'b1), .aclr
       (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (out[2]));
  CDN_flop \out_reg[3] (.clk (clk), .d (in[3]), .sena (1'b1), .aclr
       (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (out[3]));
endmodule

module adder_1(X, Y, Cin, S, Cout);
  input X, Y, Cin;
  output S, Cout;
  wire X, Y, Cin;
  wire S, Cout;
  wire n_3, n_5, n_6, n_7, n_8;
  xor g1 (n_3, X, Y);
  xor g2 (S, n_3, Cin);
  and g3 (n_5, X, Y);
  and g4 (n_6, Y, Cin);
  or g5 (n_7, n_5, n_6);
  and g6 (n_8, X, Cin);
  or g7 (Cout, n_7, n_8);
endmodule

module adder_4(X, Y, T, S, Cout);
  input [3:0] X, Y;
  input T;
  output [3:0] S;
  output Cout;
  wire [3:0] X, Y;
  wire T;
  wire [3:0] S;
  wire Cout;
  wire [3:0] Y_eff;
  wire C0, C1, C2, n_18;
  assign Cout = 1'b0;
  adder_1 ADD0(X[0], Y_eff[0], T, S[0], C0);
  adder_1 ADD1(X[1], Y_eff[1], C0, S[1], C1);
  adder_1 ADD2(X[2], Y_eff[2], C1, S[2], C2);
  adder_1 ADD3(X[3], Y_eff[3], C2, S[3], n_18);
  xor g6 (Y_eff[3], Y[3], T);
  xor g7 (Y_eff[2], Y[2], T);
  xor g8 (Y_eff[1], Y[1], T);
  xor g9 (Y_eff[0], Y[0], T);
endmodule

module counter(clk, rst_n, sel, out);
  input clk, rst_n, sel;
  output [3:0] out;
  wire clk, rst_n, sel;
  wire [3:0] out;
  wire [3:0] next_val;
  wire carry_unused, t;
  DFF ff_inst(.in (next_val), .clk (clk), .rst_n (rst_n), .out (out));
  adder_4 u_adder_4(.X (out), .Y (4'b0001), .T (t), .S (next_val),
       .Cout (carry_unused));
  not g1 (t, sel);
endmodule

module synth_wrapper(clk, rst_n, sel, out);
  input clk, rst_n, sel;
  output [3:0] out;
  wire clk, rst_n, sel;
  wire [3:0] out;
  wire [3:0] counter_out;
  wire n_5;
  counter u_counter(.clk (clk), .rst_n (rst_n), .sel (sel), .out
       (counter_out));
  not g1 (n_5, rst_n);
  CDN_flop \out_reg[0] (.clk (clk), .d (counter_out[0]), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[0]));
  CDN_flop \out_reg[1] (.clk (clk), .d (counter_out[1]), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[1]));
  CDN_flop \out_reg[2] (.clk (clk), .d (counter_out[2]), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[2]));
  CDN_flop \out_reg[3] (.clk (clk), .d (counter_out[3]), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[3]));
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
